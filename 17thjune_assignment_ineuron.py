# -*- coding: utf-8 -*-
"""17thJune_Assignment_ineuron.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1RrH_2hUriZ0ZtICVZSv0pAdauCNQ6HNn

#Q.1 What is the role of try and exception block?

Answer:
 When a program encounters an exception, it typically disrupts the normal flow of execution and can cause the program to terminate. However, by using a try-except block, you can catch and handle exceptions gracefully, allowing your program to continue running or perform alternative actions

Here's how a try-except block works:

- The code within the try block is executed.
- If an exception occurs within the try block, the execution is immediately transferred to the corresponding except block.
- The except block specifies the type of exception it can handle. If the exception raised matches the specified type, the code within the except block is executed.
- After executing the except block, the program continues to run from the point immediately after the try-except block.
"""

#program:
while True:
  try:
    a=int(input("Please enter the first number "))
    b=int(input("Please enter the first number "))
    c=a/b

  except ValueError:
    print("Please provide the value in integer only in order to complete the program")
    continue
  except ZeroDivisionError:
    print("Please do not provide the zero value of b for execution of division")
    continue
  else:
    print(f"division of two value of {a} & {b} is : {c}")
  finally:
    print("here you go with final print")
    break

"""#Q.2 What is the syntax for a basic try-except block?

Answer:

try:
    # Code that may raise an exception
    # ...
except ExceptionType1:
    # Code to handle ExceptionType1
    # ...
except ExceptionType2:
    # Code to handle ExceptionType2
    # ...
else:
    # Code that executes if no exception occurs
    # ...

#Q.3:What happens if an exception occurs inside a try block and there is no matching except block?

Answer:

If an exception occurs inside a try block and there is no matching except block to handle that specific exception, the exception will propagate up the call stack until it is caught by an outer try-except block or, if not caught at all, it will cause the program to terminate and display an error message.
"""

#Example Program:
try:
    # Code that may raise an exception
    x = 10 / 0  # Division by zero
except ValueError:
    print("This will not execute since there's no ValueError exception handling.")

"""In this example, a ZeroDivisionError will occur due to the division by zero. However, there is no except block specifically designed to handle ZeroDivisionError. As a result, the exception will propagate up the call stack and, if not caught by an outer try-except block, it will cause the program to terminate and display an error message

#Q.4: What is the difference between using a bare except block and specifying a specific exception type?

Answer:

The difference between using a bare except block and specifying a specific exception type in a try-except statement lies in how exceptions are handled.

#Example of specific Type of exception
try:
    # Code that may raise an exception
    # ...
except SpecificExceptionType:
    # Code to handle SpecificExceptionType
    # ...
Specifying specific exception types allows you to provide targeted error handling and take appropriate actions based on the specific exception that occurred. It provides more control over how different exceptions are handled in your code.

# Using a bare except block:
try:
    # Code that may raise an exception
    # ...
except:
    # Code to handle any exception
    # ...
When a bare except block is used without specifying a particular exception type, it acts as a catch-all for any exception that occurs within the try block. It will catch and handle any exception, regardless of its type.

#Q.5 Can you have nested try-except blocks in Python? If yes, then give an example.

Answer:

Yes, Python allows you to have nested try-except blocks, meaning you can have a try-except statement inside another try block.

Here's an example of nested try-except blocks:
"""

try:
    # Outer try block
    num1 = int(input("Enter the first number: "))

    try:
        # Inner try block
        num2 = int(input("Enter the second number: "))
        result = num1 / num2

    except ValueError:
        print("Invalid input for the second number. Please enter a valid integer.")

    except ZeroDivisionError:
        print("Error: Cannot divide by zero.")

    else:
        print("The result of dividing", num1, "by", num2, "is", result)

except ValueError:
    print("Invalid input for the first number. Please enter a valid integer.")

"""#Q.6 Can we use multiple exception blocks, if yes then give an example.

Answer:

Yes, we can use multiple except blocks in a try-except statement to handle different types of exceptions. This allows you to provide specific error handling for each exception
"""

#program:
try:
    # Code that may raise an exception
    num1 = int(input("Enter the first number: "))
    num2 = int(input("Enter the second number: "))

    result = num1 / num2

except ValueError:
    print("Invalid input. Please enter valid integers.")

except ZeroDivisionError:
  print("Error: Cannot divide by zero.")

except Exception as e:
    print("An error occurred:", str(e))
else:
  print(f"value of division of two number is {result}")

"""#Q.7Write the reason due to which following errors are raised:
a. EOFError
b. FloatingPointError
c. IndexError
d. MemoryError
e. OverflowError
f. TabError
g. ValueError



"""

#a. EOFError: The EOFError exception is raised when the built-in input() function encounters an end-of-file condition, typically when reading input from the console
#Program
try:
    user_input = input("Enter  input: ")
    # Process the input further...

except EOFError:
    print("End of input reached")

except Exception as e:
    print("An error occurred:", str(e))

"""b. FloatingPointError: In Python, the FloatingPointError exception does not exist as a built-in exception. However, you can handle specific floating-point arithmetic errors using other relevant exceptions like ZeroDivisionError or OverflowError, which are commonly associated with floating-point calculations. which is already explained"""

#c. IndexError: The IndexError exception is raised when you try to access an index that is out of range for a sequence (e.g., a list, tuple, or string)
try:
    my_list = [1, 2, 3]
    print(my_list[3])  # Accessing index 3, which is out of range

except IndexError:
    print("Error: Index out of range.")

except Exception as e:
    print("An error occurred:", str(e))

#d:MemoryError: The MemoryError exception is raised when an operation or expression requires more memory than is available
try:
    # Code that may raise a MemoryError
    data = [0] * (10**9)  #  create a large list

except MemoryError:
    print("Error: Insufficient memory to perform the operation.")

except Exception as e:
    print("An error occurred:", str(e))

#e. OverflowError:The OverflowError exception is raised when a calculation exceeds the maximum representable value in Python
try:
    result = 10 ** 1000  # Attempting to calculate a very large exponentiation

except OverflowError:
    print("Error: Calculation exceeds the maximum representable value.")

except Exception as e:
    print("An error occurred:", str(e))

#f. TabError: The TabError exception is raised when there is an issue with the indentation of your Python code

try:
  #code that may raise the taberror
except TabError:
  print("Error: Indentation error in the code.")
except Exception as e:
  print("An error occurred:", str(e))

#g. : ValueError: The ValueError exception is a common exception in Python that is raised when an operation or function receives an argument of the correct type but an inappropriate value

try:
    # Code that may raise a ValueError
    num = int(input("Enter a number: "))

except ValueError:
    print("Error: Invalid value entered. Please enter a valid number.")

except Exception as e:
    print("An error occurred:", str(e))

"""#Q.8: Write code for the following given scenario and add try-exception block to it.

a. Program to divide two numbers
b. Program to convert a string to an integer
c. Program to access an element in a list
d. Program to handle a specific exception
e. Program to handle any exception

"""

#a. Program to divide two numbers
try:
    # Code that may raise an exception
    num1 = int(input("Enter the first number: "))
    num2 = int(input("Enter the second number: "))

    result = num1 / num2

except ValueError:
    print("Invalid input. Please enter valid integers.")

except ZeroDivisionError:
  print("Error: Cannot divide by zero.")

except Exception as e:
    print("An error occurred:", str(e))
else:
  print(f"value of division of two number is {result}")

#b. Program to convert a string to an integer
try:
  str_input=input("Please provide the string input in order to convert into integer")
  in_out=int(str_input)
except ValueError:
  print("Please provide the input integer only")
else:
  print(f"finally correct input has been give & output is {in_out}")

#c. Program to access an element in a list
try:
  list1=[1,2,3]
  i=int(input("please provide the index value to get the item from above list"))
  t=list1[i]
except IndexError:
  print("You are trying to access the value which is not present in the list so please give the correct")
else:
  print(f"value of t from list is {t}")

#d. Program to handle a specific exception
try:
    result = 10 ** 1000  # Attempting to calculate a very large exponentiation

except OverflowError:
    print("Error: Calculation exceeds the maximum representable value.")

except Exception as e:
    print("An error occurred:", str(e))

#e. Program to handle any exception
try:
    # Code that may raise an exception
    num1 = int(input("Enter the first number: "))
    num2 = int(input("Enter the second number: "))
    result = num1 / num2
except:
    print("Invalid input. Please enter valid integers.")
else:
  print(f"value of division of two number is {result}")