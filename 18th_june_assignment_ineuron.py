# -*- coding: utf-8 -*-
"""18th June_Assignment_ineuron.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12NqMr3-vPdtLDWCeg1P2YiZDQjXkdu93

#Q.1: What is the role of the 'else' block in a try-except statement? Provide an example scenario where it would be useful.

Answer:


The else block in a try-except statement is optional and provides a block of code that is executed if no exceptions are raised in the try block. It allows you to specify code that should be executed only if the try block completes successfully without any exceptions.
"""

def divide_numbers(a, b):
    try:
        result = a / b
    except ZeroDivisionError:
        print("Error: Division by zero occurred.")
    else:
        print("The division result is:", result)#if above try statement will execute without error so its output will get print in cell.


# Test the function
num1 = float(input("Enter the first number: "))
num2 = float(input("Enter the second number: "))
divide_numbers(num1, num2)

"""#Q.2: 2. Can a try-except block be nested inside another try-except block? Explain with an example.

Answer:
Yes, Python allows you to have nested try-except blocks, meaning you can have a try-except statement inside another try block.

Here's an example of nested try-except blocks:

"""

try:
    # Outer try block
    num1 = int(input("Enter the first number: "))

    try:
        # Inner try block
        num2 = int(input("Enter the second number: "))
        result = num1 / num2

    except ValueError:
        print("Invalid input for the second number. Please enter a valid integer.")

    except ZeroDivisionError:
        print("Error: Cannot divide by zero.")

    else:
        print("The result of dividing", num1, "by", num2, "is", result)

except ValueError:
    print("Invalid input for the first number. Please enter a valid integer.")

"""#Q.3:How can you create a custom exception class in Python? Provide an example that demonstrates its usage.

Answer:
In Python, you can create a custom exception class by defining a new class that inherits from the built-in Exception class or any of its subclasses. By creating a custom exception class, you can define your own exception types that suit your specific needs and provide customized error handling
"""

class CustomException(Exception):
  pass

def check_num(num):
  if num<0:
    raise CustomException("Error: Provided value is negative so pleae provide the positive value")
try:
  n1=int(input("Please provide the number"))
  check_num(n1)
  print(f"value is given correct :{n1}")
except Exception as e:
  print(str(e))

"""#Q.4: What are some common exceptions that are built-in to Python?

Answer:


Python provides several built-in exception classes that cover a wide range of common error scenarios.

1. Exception: The base class for all exceptions. It can be used to catch any exception.

2. TypeError: Raised when an operation or function is performed on an object of an inappropriate type.

3. ValueError: Raised when an operation or function receives an argument of the correct type but an inappropriate value.

4. NameError: Raised when a local or global name is not found.

5. IndexError: Raised when an index is out of range for a sequence.

6. KeyError: Raised when a dictionary key is not found.

7. ZeroDivisionError: Raised when division or modulo operation is performed with zero as the divisor.

8. FileNotFoundError: Raised when a file or directory is requested but cannot be found.

9. ImportError: Raised when an imported module or a specific attribute within a module cannot be found.

10 AttributeError: Raised when an attribute reference or assignment fails.

11. IOError: Raised when an input/output operation fails, such as when reading or writing to a file.

#Q.5:  5. What is logging in Python, and why is it important in software development?
Answer:

Logging in Python refers to the process of recording log messages during the execution of a program. It involves capturing important information, such as errors, warnings, informational messages, and debugging details, and saving them to a log file or displaying them on the console.

Logging is important in software development for several reasons:
1. Troubleshooting and Debugging
2. Error Reporting and Analysis
3. Performance Monitoring
4. Auditing and Compliance
5. Historical Analysis and Data Mining:

#Q.6:  Explain the purpose of log levels in Python logging and provide examples of when each log level would be appropriate.

Answer:

In Python logging, log levels are used to categorize log messages based on their severity or importance. Each log level represents a different level of criticality, allowing developers to control which log messages are recorded or displayed based on their relevance

Python provides the following log levels, in increasing order of severity:

1. DEBUG: This log level is used for detailed debugging information. It is typically used during development to provide the most granular and low-level information about the program's execution, helping developers trace the flow of code and identify issues. Example usage: Logging variable values, function calls, or detailed debugging information.

2. INFO: This log level is used for informational messages that indicate the normal flow of the program. It provides higher-level information to track the progress of the application and important events that occur during its execution. Example usage: Logging application startup, important configuration details, or major milestones.

3. WARNING: This log level is used for non-critical issues or warnings. It indicates potential problems or unexpected situations that may not be fatal to the program but require attention. Example usage: Logging deprecated function usage, potential performance bottlenecks, or non-fatal errors that the application can recover from.

4. ERROR: This log level is used for critical errors that may impact the functionality or expected behavior of the program. It indicates conditions that should be investigated and resolved. Example usage: Logging exceptions, unexpected errors, or conditions that prevent the application from functioning properly.

5. CRITICAL: This log level is used for severe errors or failures that may result in the termination of the program or significant data loss. It represents the highest level of severity. Example usage: Logging unrecoverable errors, security breaches, or catastrophic failures.

#Q.7: What are log formatters in Python logging, and how can you customise the log message format using formatters?

Answer:

In Python logging, log formatters are used to define the format of log messages before they are emitted or written to log files or other destinations.
"""

import logging

# Create a logger
logger = logging.getLogger("my_logger")
logger.setLevel(logging.DEBUG)

# Create a formatter
formatter = logging.Formatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s")

# Create a console handler and set the formatter
console_handler = logging.StreamHandler()
console_handler.setFormatter(formatter)

# Add the console handler to the logger
logger.addHandler(console_handler)

# Log messages
logger.debug("This is a debug message")
logger.info("This is an info message")
logger.warning("This is a warning message")
logger.error("This is an error message")

"""we are creating a logger named "my_logger" and set its log level to DEBUG using logger.setLevel(logging.DEBUG)

we are creating a Formatter object and define the log message format using format codes:

- %(asctime)s: Inserts the timestamp of the log message in the format specified by datefmt (if provided) or the default format.
- %(name)s: Inserts the logger name.
- %(levelname)s: Inserts the log level name (e.g., DEBUG, INFO, WARNING, ERROR).
- %(message)s: Inserts the actual log message.

By customizing the formatter, you can control the layout, content, and additional information included in the log messages. You can include placeholders for timestamps, log levels, logger names, process IDs, thread names, and any other relevant information.

#Q.8:  How can you set up logging to capture log messages from multiple modules or classes in a Python application?

Answer:
To capture log messages from multiple modules or classes in a Python application, you can follow these steps:

1. Create a Logger: In each module or class where you want to capture log
  messages, create a logger using the logging.getLogger() function. Use a unique name for each logger to differentiate them.

  import logging

  logger = logging.getLogger("module_logger")

2. Set the Logger's Log Level: Set the log level for each logger based on the desired level of granularity. You can set it to DEBUG, INFO, WARNING, ERROR, or CRITICAL, depending on your needs.

  logger.setLevel(logging.DEBUG)

3. Configure a Handler: Configure a handler to specify where the log messages
   should be directed. You can use a StreamHandler to direct the messages to the console or a FileHandler to save them in a file.

  console_handler = logging.StreamHandler()

  logger.addHandler(console_handler)

4. Set the Formatter: Set the formatter for the handler to specify the     format    of the log messages. You can use the default formatter or create a custom formatter using the logging.Formatter class.

  formatter = logging.Formatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s")

  console_handler.setFormatter(formatter)

5. Log Messages: In each module or class, use the created logger to log messages at the desired log levels.

 logger.debug("This is a debug message")
 logger.info("This is an info message")
 logger.warning("This is a warning message")
 logger.error("This is an error message")


By following these steps, you can set up logging to capture log messages from multiple modules or classes in your Python application. Each module or class will have its own logger, and you can configure different log levels, handlers, and formatters for each logger as

When the log messages are generated, they will be directed to the specified handler(s) based on the logger's configuration, and the log messages will be displayed or saved according to the specified format.

#Q.9: What is the difference between the logging and print statements in Python? When should you use logging over print statements in a real-world application?

Answer:

The logging and print statements in Python serve different purposes and have different use cases. Here are the main differences between them:

- **Output Destination**: The print statement prints the output directly to the console, while the logging module allows you to configure the output destination, such as writing log messages to a file, sending them to a remote server, or displaying them on the console.

- **Granularity and Level of Detail:** The print statement is typically used for general output and is often used during development for quick debugging or displaying intermediate results. On the other hand, the logging module provides different log levels (e.g., DEBUG, INFO, WARNING, ERROR, CRITICAL) to categorize log messages based on their severity. This allows you to control the level of detail captured in logs, making it easier to focus on specific types of information (e.g., errors, warnings) during troubleshooting.

- **Configurability:** The print statement has limited configurability. You can only control what is printed and where it is printed. In contrast, the logging module offers extensive configuration options. You can customize the log format, log levels, log destinations, and even create multiple loggers with different configurations for different parts of your application.

#When to use logging over print statements in a real-world application:

- **Debugging and Troubleshooting**: Logging is particularly useful for debugging and troubleshooting purposes. Instead of scattering print statements throughout your code, using logging allows you to selectively enable or disable the output based on log levels. You can also provide more detailed information, such as timestamps, log levels, and additional contextual data, to aid in debugging and understanding the program flow.

- **Production Environment:** When running your application in a production environment, using print statements is generally discouraged. Print statements can clutter the console or create unnecessary output that might interfere with the application's performance. Logging, on the other hand, provides a more controlled and structured approach to capturing relevant information, allowing you to monitor and analyze the application's behavior without affecting its performance.

- **Log File Persistence**: Using logging allows you to save log messages to a file for long-term storage and analysis. This is particularly important for auditing, compliance, or historical analysis purposes. Print statements do not provide built-in mechanisms for saving the output to a file or archiving it for future reference.

#Q.10: Write a Python program that logs a message to a file named "app.log" with the following requirements:

● The log message should be "Hello, World!"

● The log level should be set to "INFO."

● The log file should append new log entries without overwriting previous ones.
"""

#Answer: Please follow this below code with respect of above points in order to better understanding

# The log message should be "Hello, World!"
#import logging module
import logging
# setting the level of DEBUG & filename & format of message should get print in the filename of app.log
logging.basicConfig(filename="app.log",level=logging.DEBUG,format="%(levelname)s %(asctime)s %(name)s %(message)s")

#printing basic information
logging.info("Hello World")

# The log level should be set to "INFO."


#import logging module
import logging
# setting the level of INFO
logging.basicConfig(filename="app.log",level=logging.INFO,format="%(levelname)s %(asctime)s %(name)s %(message)s")

logging.info("Hello World")

#The log file should append new log entries without overwriting previous ones.

#import logging module
import logging

logging.basicConfig(filename="app.log",level=logging.DEBUG,format="%(levelname)s %(asctime)s %(name)s %(message)s")

#here we are printing the other informaton in same file without overriding.
logging.info("Hello World")
logging.debug("here you go with debugging")
logging.error("here you go with error")

"""#Q.11: Create a Python program that logs an error message to the console and a file named "errors.log" if an exception occurs during the program's execution. The error message should include the exception type and a timestamp.

Answer:

 Here's an example Python program that logs an error message to the console and a file named "errors.log" if an exception occurs during its execution:

"""

import logging
logging.basicConfig(filename="errors.log",level=logging.ERROR,format="%(levelname)s %(asctime)s %(name)s %(message)s")


def divide(a,b):
    logging.info(f"the number entered by user is {a} and {b}")
    try:
        logging.info("we are into function")
        div = a/b
        logging.info("we have completed a division operation")
        logging.info(f"The division of two value is {div}")
    except Exception as e:
        logging.error(e)
(divide(15,0))